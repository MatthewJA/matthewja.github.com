// Generated by CoffeeScript 1.6.3
/*
CLASSES
*/


(function() {
  var Snake, draw, getMainLoop, start, update, updateCanvasSize;

  Snake = (function() {
    function Snake(x, y) {
      this.x = x;
      this.y = y;
      this.d = 0;
      this.v = 0.00025;
      this.targetR = 11;
      this.r = this.targetR;
      this.dr = 2;
      this.x0 = this.x - this.radius();
      this.y0 = this.y;
      this.colour = {
        snake: "#EFEFEF",
        debug: "#444444"
      };
      this.showDebugLines = true;
      this.width = 0.015;
      /*
      			Tails are confusing, so I will explain my logic.
      			I will draw circular arcs, seeing as the snake is circular, right?
      			To draw an arc, we need to store the start angle, the end angle, and the @r value (from which
      			we can get the radius).
      			So inside the tail array, we'll store objects with properties start, end, and @r.
      */

      this.tail = [];
      this.maxTailLength = 0.1;
      this.currentTailLength = 0;
    }

    Snake.prototype.radius = function(r) {
      if (r == null) {
        r = null;
      }
      if (r != null) {
        return Math.abs(1 / r);
      } else {
        return Math.abs(1 / this.r);
      }
    };

    Snake.prototype.dealWithD = function(d) {
      if (d < 0) {
        if (d < -2 * Math.PI) {

        }
      } else {
        return d;
      }
    };

    Snake.prototype.move = function(dt) {
      var d, firstArc, firstArcRadius, lastSegmentLength, lengthToRemove, radiansToRemove;
      this.updateRadius(dt);
      console.log(this.tail[0], this.tail.length);
      d = this.d + this.v / this.radius() * dt;
      if (this.tail.length > 0 && this.tail[this.tail.length - 1].r === this.r) {
        console.log("extending");
        if (d > this.d) {
          this.tail[this.tail.length - 1].end += d - this.d;
        } else {
          this.tail[this.tail.length - 1].end += this.d - d;
        }
      } else {
        if (d > this.d) {
          this.tail.push({
            start: this.d,
            end: d,
            r: this.r,
            x0: this.x0,
            y0: this.y0,
            cc: false
          });
        } else {
          this.tail.push({
            start: this.d,
            end: -d - 2 * Math.PI,
            r: this.r,
            x0: this.x0,
            y0: this.y0,
            cc: true
          });
        }
      }
      lastSegmentLength = Math.abs(d - this.d) * this.radius();
      this.currentTailLength += lastSegmentLength;
      if (this.currentTailLength > this.maxTailLength) {
        firstArc = this.tail[0];
        firstArcRadius = this.radius(firstArc.r);
        lengthToRemove = this.currentTailLength - this.maxTailLength;
        radiansToRemove = lengthToRemove / firstArcRadius;
        if (firstArc.start < firstArc.end) {
          firstArc.start += radiansToRemove;
          if (firstArc.start >= firstArc.end) {
            this.tail.shift();
          }
        } else {
          firstArc.start -= radiansToRemove;
          if (firstArc.start <= firstArc.end) {
            this.tail.shift();
          }
        }
        this.currentTailLength = this.maxTailLength;
      }
      this.d = d;
      this.x = this.radius() * Math.cos(this.d) + this.x0;
      return this.y = this.radius() * Math.sin(this.d) + this.y0;
    };

    Snake.prototype.updateRadius = function(dt) {
      var cs, k, r, x1, y1;
      if (this.r === this.targetR || Math.abs(this.r - this.targetR) < 0.001) {
        this.r = this.targetR;
        return;
      }
      if (dt > 0) {
        cs = dt / 3;
        r = (this.r * (cs - 1) + this.targetR) / cs;
      } else {
        r = this.r;
      }
      if (this.r < 0 && r > 0) {
        k = this.r / Math.abs(r);
      } else if (this.r > 0 && r < 0) {
        k = Math.abs(this.r) / r;
      } else {
        k = this.r / r;
      }
      x1 = k * (this.x0 - this.x) + this.x;
      y1 = k * (this.y0 - this.y) + this.y;
      if ((r < 0 && this.r > 0) || (r > 0 && this.r < 0)) {
        this.d = this.d + Math.PI;
        this.v = -this.v;
      }
      this.r = r;
      this.x0 = x1;
      return this.y0 = y1;
    };

    Snake.prototype.turn = function(direction) {
      return this.targetR = this.r - this.dr * direction;
    };

    Snake.prototype.draw = function(context) {
      var entry, size, _i, _len, _ref;
      size = context.canvas.width;
      if (this.showDebugLines) {
        context.lineWidth = this.width / 10 * size;
        context.strokeStyle = this.colour.debug;
        context.fillStyle = this.colour.debug;
        context.beginPath();
        context.arc(this.x0 * size, this.y0 * size, this.width * size / 4, 0, 2 * Math.PI);
        context.closePath();
        context.fill();
        context.beginPath();
        context.arc(this.x0 * size, this.y0 * size, this.radius() * size, 0, 2 * Math.PI);
        context.closePath();
        context.stroke();
      }
      context.lineWidth = this.width * size / 2;
      context.strokeStyle = this.colour.snake;
      context.beginPath();
      _ref = this.tail;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entry = _ref[_i];
        context.arc(entry.x0 * size, entry.y0 * size, this.radius(entry.r) * size, entry.start, entry.end, entry.cc);
      }
      context.stroke();
      context.fillStyle = this.colour.snake;
      context.beginPath();
      context.arc(this.x * size, this.y * size, this.width * size, 0, 2 * Math.PI);
      context.closePath();
      return context.fill();
    };

    Snake.prototype.handleKeyPress = function(key) {
      switch (key) {
        case 37:
        case 65:
          return this.turn(1);
        case 39:
        case 68:
          return this.turn(-1);
      }
    };

    return Snake;

  })();

  /*
  HELPER FUNCTIONS
  */


  /*
  MAIN FUNCTIONS
  */


  updateCanvasSize = function(canvas, context) {
    var height, width;
    height = Math.min(window.innerHeight, window.innerWidth);
    width = height;
    canvas.style.width = "" + width + "px";
    canvas.style.height = "" + height + "px";
    context.canvas.width = width;
    return context.canvas.height = height;
  };

  update = (function() {
    return update = function(dt, entities) {
      var entity, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = entities.length; _i < _len; _i++) {
        entity = entities[_i];
        _results.push(typeof entity.move === "function" ? entity.move(dt) : void 0);
      }
      return _results;
    };
  }).call(this);

  draw = (function() {
    var colour;
    colour = {
      background: "#222222",
      snake: "#EFEFEF"
    };
    return draw = function(context, entities) {
      var entity, _i, _len, _results;
      context.fillStyle = colour.background;
      context.fillRect(0, 0, context.canvas.width, context.canvas.height);
      _results = [];
      for (_i = 0, _len = entities.length; _i < _len; _i++) {
        entity = entities[_i];
        _results.push(entity.draw(context));
      }
      return _results;
    };
  }).call(this);

  getMainLoop = (function(canvas, entities) {
    var context, lastUpdate, mainLoop;
    context = canvas.getContext("2d");
    lastUpdate = (new Date()).getTime();
    return mainLoop = function(fps) {
      var dt, now;
      now = (new Date()).getTime();
      dt = now - lastUpdate;
      lastUpdate = now;
      updateCanvasSize(canvas, context);
      update(dt, entities);
      draw(context, entities);
      if (dt !== 0) {
        document.title = 1000 / dt + " fps";
      }
      return setTimeout(mainLoop, 1 / fps * 1000);
    };
  });

  start = (function() {
    var canvas, entities, handleKeyPress;
    canvas = document.getElementById("canvas");
    entities = [];
    entities.push(new Snake(0.5, 0.5));
    handleKeyPress = function(e) {
      var entity, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = entities.length; _i < _len; _i++) {
        entity = entities[_i];
        _results.push(typeof entity.handleKeyPress === "function" ? entity.handleKeyPress(e.keyCode) : void 0);
      }
      return _results;
    };
    return start = function() {
      canvas.addEventListener("keydown", handleKeyPress, false);
      canvas.focus();
      return getMainLoop(canvas, entities)(60);
    };
  }).call(this);

  start();

}).call(this);
